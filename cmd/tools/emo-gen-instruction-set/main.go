package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"strings"
)

const template = `// Code generated by emo-gen-instruction-set. DO NOT EDIT.
// source: %s

package cpu

const (%s
)

var instructionSet = [%d]instruction{%s
}
`

var (
	instructionsFileName   = os.Args[1]
	instructionSetFileName = os.Args[2]
)

func parseInstructionNamesFromFile(name string) (names []string) {
	file, err := parser.ParseFile(
		token.NewFileSet(),
		name,
		nil,
		parser.AllErrors,
	)
	if err != nil {
		log.Fatal(err)
	}
	for _, decl := range file.Decls {
		switch x := decl.(type) {
		case *ast.FuncDecl:
			if x.Name.IsExported() {
				names = append(names, x.Name.Name)
			}
		}
	}
	return
}

func writeInstructionSetFile(name string, names []string) {
	file, err := os.Create(instructionSetFileName)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	fmt.Fprint(file, generateInstructionSet(names))
}

func generateInstructionSet(names []string) string {
	return fmt.Sprintf(template,
		instructionsFileName,
		instructionNamesToOpcodeList(names),
		len(names), instructionNamesToList(names),
	)
}

func instructionNamesToList(names []string) string {
	var buf strings.Builder
	for _, name := range names {
		fmt.Fprintf(&buf, "\n\t%s,", name)
	}
	return buf.String()
}

func instructionNamesToOpcodeList(names []string) string {
	var buf strings.Builder
	for i, name := range names {
		fmt.Fprintf(&buf, "\n\tOpcode%s uint8 = %d", name, i)
	}
	return buf.String()
}

func main() {
	writeInstructionSetFile(
		instructionSetFileName,
		parseInstructionNamesFromFile(instructionsFileName),
	)
	err := exec.Command("go", "fmt", instructionSetFileName).Run()
	if err != nil {
		log.Println("failed to go fmt generated file:", err)
	}
}
